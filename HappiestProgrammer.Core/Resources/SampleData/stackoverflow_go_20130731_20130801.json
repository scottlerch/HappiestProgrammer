{"DataSource":"stackoverflow.com","CommentId":"26393518","Text":"I experience SO as sometimes hostile towards newbees. Why the 3 downvotes? It would help the newbee if you tell <i>why</i> this is a bad question (which I don&#39;t think it is).","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26349637","Text":"OOP in C? why??","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26326978","Text":"@PuerkitoBio -- I&#39;ll add the info about white box testing since the OP specifically mentioned it.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26326970","Text":"@Matt -- Sure, you know you changed it, but do you remember all the places you referenced it in your tests? When I make name changes, my tests fail to compile and tell me the lines I need to change. Unsafe won&#39;t do that, at best it will quietly panic when you try to get the UnsafeAddr of the zero value, at worst you&#39;ll change the wrong field and have to spend an hour tracking down the fact that you&#39;re subtly overwriting the wrong data with gibberish.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26323458","Text":"Yep. I didn&#39;t spot it.  Glad it works now.  Updated my answer for future SO users... hopefully it will help someone.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26321675","Text":"Go client uses http 1.1 by default. Setting the header is not the issue. Go needs the Response Body to be closed for a connection to be reused.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26317129","Text":"The way the question was written (i.e. &quot;set maximum number&quot;) led me to believe you were attempting to limit outbound connections not re-use them.  I can now infer that you want to reuse connections to the degree that is possible. You just need to set the Keep-Alive header  The python requests library handles keep-alive for you, while go does not.  I&#39;ll add a snippet to my answer.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26314300","Text":"White box testing is easily done by putting your *_test.go files in the same package as the one under test, so you have access to unexported fields. The Go tools correctly support this use-case and will not compile your tests with your package code except when running <code>go test</code>.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26312596","Text":"Just to be clear, all these packages are my own, so if I change the name of a field, I would know about it. I had two potential uses in mind: White box testing, which your solution definitely works for, but also a parser, which converts strings to the objects in the other package, whose efficiency would benefit from bypassing the usual constructors for the structs but your solution would defeat the purpose of that. Of course, I could put the parser in the same package, but I wanted to keep the various parts of the program separate (maybe that&#39;s not very Go-like?).","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26312142","Text":"That might be handled when you <code>return</code>, but I guess adding a <code>defer close(quit)</code> and <code>defer close(done)</code> in your <code>handler_request_checker</code> cannot harm","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26311993","Text":"@elithrar All of it is my code. So... yes, they are unexposed for a good reason; and yes, I do need to access them.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26311435","Text":"Great answer, and +1000 on &quot;[...] no qualms about changing the names of things users should be unaware of&quot;. It is unexported for a reason.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26295202","Text":"I added a python equivalent code. that piece of code does what is expected, open only one connection.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26295192","Text":"Edited question simplified example with only a for loop. No go routines. Added equivalent python code, which does the right thing.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26291863","Text":"Can you not fork the existing library and expose the fields that you need to modify? (note that you should assume they&#39;re unexposed for a good reason)","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26284334","Text":"I had presented an example app and I was pointed in the direction of a hashmap with mutex. I would have loved to be able to use channels but I&#39;m not sure how it would be accomplished. Would you mid taking a look at the original post? <a href=\"http://stackoverflow.com/questions/17890830/golang-shared-communication-in-async-http-server\" title=\"golang shared communication in async http server\">stackoverflow.com/questions/17890830/&hellip;</a>","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26283999","Text":"@kwolfe: It depends on the rest of your code, but it&#39;s pretty possible  that a channel of such IDs is a much better fit for your task than a concurrently accessed map is.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26282793","Text":"I suppose I should have mentioned that the ID that I&#39;ll be reading from is set up to be only written to once, and read once, before being removed. It is a unique identifier for the call. So I should be good with a check every 100 miliseconds? How is the read treated by go if the read occurs while there is a lock?","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26282478","Text":"With protected fields you can directly access them in methods of derived classes. Here you would have to create public accessor methods for those field, even if you don&#39;t want to make them public. I just took the SetAge() method as example. But think of any other method due to the logic. You don&#39;t hide the method of the parent type, it&#39;s callable as shown above.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26275569","Text":"I&#39;m rewriting it right now, but I think I found the catch. I removed <code>return</code> from <code>quit</code> case and increase counter on all events(both success and fail). In that case I not quit <code>handler_request_checker</code> until I receive all <code>done</code> signals. I think high memory usage happens because I did <code>return</code> before all goroutinies finished.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26274390","Text":"Of course not! Of course everything can be written in pure assembly but this doesn&#39;t mean <b>abstractions</b> and <b>concepts</b> are syntax sugar (syntax sugar = a shortcut to write something more friendly/shortly, they don&#39;t/can&#39;t change behavior). You can program  OOP-style in C but it&#39;s still OOP, inheritance doesn&#39;t change <b>meaning</b> and <b>expected behavior</b> (doesn&#39;t matter how language exposes that).","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26273754","Text":"I understand. Thanks.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26273618","Text":"inheritance is sugar. If you get down to the nuts and bolts of programming, you find that most of the abstractions we depend upon in the OO world are nothing more than syntax sugar. Its why they break. Its why OO doesn&#39;t scale when using Threads. Its all smoke and mirrors.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26273509","Text":"If Go didn&#39;t use syntax sugar, I would be calling Person.Thing.SetAge(), not Person.SetAge(). This I think is the confusion. It looks like inheritance, acts like inheritance, but in fact is old school functional decomposition.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26273383","Text":"But composition/inheritance are not syntax sugar, they&#39;re different behaviors!","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26273266","Text":"well yes, the constructor in Go is something else :)","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26273242","Text":"You talking about shared memory space?","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26273207","Text":"the difference is not the override itself. It&#39;s in how you call it (and how the virtual call is resolved to the actual derived type that the variable contains). If I have time I&#39;ll try adding a counter-example in Go","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26273174","Text":"Oops, soory, unsure about Request.Body. Most probably you&#39;ll have to show real buggy code.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26273117","Text":"Check my code above...I added an override in Go...didn&#39;t do much to the override..but it does something.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26273085","Text":"@WeNeedAnswers: I&#39;m not sure if I made a good example, but please have a look at <a href=\"http://play.golang.org/p/N3LIEt0xTR\" rel=\"nofollow\">play.golang.org/p/N3LIEt0xTR</a> The point is that the &quot;base&quot; class doesn&#39;t see if it exists alone or is embedded in any child type. All what <code>Thing</code>&#39;s method see is only the <code>Thing</code>. If the child type overrides Thing&#39;s method, within a Thing the non-overridden method would still be called instead.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26272989","Text":"I have extended Person by adding a new Struct called UglyPerson and giving him wonkyTeeth. I don&#39;t see a problem so far?","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26272791","Text":"Why would I implement a SetAge in Cat if I didn&#39;t want to override? I can still call the SetAge method within the Cat SetAge method?","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26272709","Text":"I don&#39;t know, I think that this form of composition is a little different to normal Object composition. It is clear when creating a system that an object is composed of many objects. But the syntax sugar in go would give the Cat and Person GetName().","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26272636","Text":"I would say shares traits of a thing.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26272594","Text":"But the syntax sugar, makes it feel like inheritance, isn&#39;t this all there is really to inheritance when using an OO language?","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26272551","Text":"+1 right but looking at original question I wouldn&#39;t beat that OP did understand what you mean...","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26272345","Text":"could you give an example of what your saying please, using the daft code I have above? Just so that I understand fully. I don&#39;t know, add ShoeSize :)","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26272256","Text":"No, <b>as you said</b> it&#39;s <b>not inheritance</b> but <b>composition</b>. To be pedantic...what do you say? person IS a thing or person HAS a thing? You can&#39;t pass a thing instead of a person. About interfaces well yes, it&#39;s <b>somehow</b> inheritance but you can&#39;t inherit implemented behaviors, just their definition. Imagine to say that a person CAN DO something (but each implementer has to do it in its own way).","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26272250","Text":"Don&#39;t you get this problem with ordinary inheritance in languages such as C#? hence the base.something() call, or the Overriding of methods to hide the base?","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26267533","Text":"Even when I use only server implementation of http package? I put <code>r.Body.Close()</code> in the <code>handler_request_checker</code> function, but it didn&#39;t help.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26264288","Text":"Your <code>handler_request_checker</code> does not close r.Body which must be done.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26261138","Text":"I added example of goroutine to the question","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26260741","Text":"AFACIS, nothing wrong in the code you shown. Probably something wrong in the code you didn&#39;t show.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26253452","Text":"<code>setColor</code> doesn&#39;t do what you think it does. You should make <code>c</code> (the receiver) a <i>pointer</i> to a Car.","Language":"go"}
{"DataSource":"stackoverflow.com","CommentId":"26253047","Text":"I do not think <code>MaxIdleConnsPerHost</code> is doing what you think it&#39;s doing.  It&#39;s meant to support HTTP 1.1 Keep-Alives, not limit the number of hosts you connect to.  It also seems like you&#39;re doing the <code>HTTP GET</code> in a slightly raw way.  Can you adapt <a href=\"http://golang.org/pkg/net/http/#example_Get\" rel=\"nofollow\">golang.org/pkg/net/http/#example_Get</a> instead?","Language":"go"}