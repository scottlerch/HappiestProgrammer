[{"DataSource":"stackoverflow.com","CommentId":"26323844","Text":"@SergeyK. if you are going to keep editing the title back to boobs please make it consistant with the terminology in the post as well. Otherwise not only is it offensive to some people it is inconsistant as well.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26320147","Text":"If your problem has been solved, perhaps you could <a href=\"http://meta.stackoverflow.com/questions/5234/how-does-accepting-an-answer-work\">accept</a> the answer?","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26318947","Text":"how does it work or <a href=\"http://stackoverflow.com/q/17972422#comment26309088_17972624\">what does it do</a> is two different questions. Sure you didn&#39;t mean the 2nd one?","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26316237","Text":"Thank you for clarifying this function!","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26313847","Text":"Another version of this question: <a href=\"http://stackoverflow.com/questions/15029843/how-can-i-understand/15030372\" title=\"how can i understand\">stackoverflow.com/questions/15029843/how-can-i-understand/&hellip;</a>","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26309088","Text":"@dorchard expanding what you said, it&#39;s &quot;combine a unary and a binary function to create a new binary function that when applied to two arguments, will produce its result by applying the unary function to the result of applying the binary function to the two arguments&quot;.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26300755","Text":"To avoid confusion is GADTs it&#39;s best to keep the result types of the constructors as consistent as possible.  In this case <code>Cast :: (Castable b a) =&gt; Expr b -&gt; Expr a</code> would probably have been enough for you to understand what the problem was.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26298744","Text":"I solve my problem. Thank you, @mathematicalorchid.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26291414","Text":"OK, thanks so much for your comments. Along with @Ben&#39;s answer, they really helped. Ultimately, the real question was how to create an expression type that allowed for type-aware casting. I didn&#39;t fully grok that by creating this GADT I was losing <code>b</code>&#39;s type (except for the <code>Castable</code> constraint). For future reference, to fix this particular <code>Show</code> problem, I can just add a <code>Show b</code> constraint in <code>Cast</code>.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26291217","Text":"@Wes Showing the expression isn&#39;t that important; ultimately I&#39;m going to evaluate it, but I thought it should be possible. What do you mean by confusing <code>Expr a</code> with <code>Expr b</code>? I just saw your second suggestion: that&#39;s interesting, although I want to be able to cast between many instances. I think that your code wouldn&#39;t allow <code>Cast (Cast (Value (3 :: Word64)) :: Expr Word32) :: Expr Word16</code>.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26291212","Text":"I think a full explanation of GADT behavior is outside the scope of this comment field. Note that your <code>Cast</code> declaration is also equivalent to e.g. <code>Cast :: Castable a b =&gt; Expr b -&gt; Expr a</code> -- GADT variables aren&#39;t scoped. I don&#39;t know what your &quot;real question&quot; -- what you&#39;re actually trying to do -- is, but I suspect it deserves its own SO question (to which a GADT might well be the answer).","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26291205","Text":"@nitromaster101 it may be true that you&#39;ve used it in such a way that the result is an instance of <code>Show</code> but the compiler can&#39;t prove that it will <i>always</i> be the case that you&#39;ve called it with something you can show.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26291190","Text":"Along the same lines as @shachaf, you should consider using a parsing package, like <code>Parsec</code> or <code>attoparsec</code> for converting text to Haskell data types.  These packages will feature numeric parsers that you can use much more easily than <code>readInt</code>.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26291068","Text":"@shachaf: I don&#39;t understand why this GADT is equivalent to the standard data constructor (the important difference is that in the GADT, <code>Cast</code> takes one type and converts to another). I understand that there might be a problem printing an arbitrary <code>Expr a</code> because I don&#39;t know the type <code>b</code> which satisfies <code>Castable</code>, but once I&#39;m dealing with a specific instance (like <code>e</code> in main), I don&#39;t know why it shouldn&#39;t be able to work.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26291051","Text":"@nitromaster101 the problem is that you&#39;re confusing <code>Expr a</code> with <code>Expr b</code> in the instance declaration for <code>Castable</code>. I&#39;m not sure exactly which behaviour you want although I doubt you want the first version I posted. Why do you want to show the result of the cast anyway?","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26291001","Text":"@Wes: Your code compiles but you changed the type of the <code>Cast</code> constructor.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26290821","Text":"I agree with shachaf, I&#39;m not sure what you actually want here.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26290808","Text":"@SergeyK When you&#39;ve already got <code>a</code> and <code>b</code> lying around, <code>f (g a b)</code> is usually clearer. When you&#39;re trying to pass the function rather than apply it (you want to give it to <code>map</code> or <code>filter</code> or something), then you&#39;d have to say <code>map (\\a b -&gt; f (g a b))</code>. If you&#39;re familiar with the behaviour of <code>(.).(.)</code> then <code>map ((.).(.) f g)</code> introduces less &quot;noise&quot;; it&#39;s just the application of a function you know to two arguments, whereas a lambda is a function <i>definition</i> which has to be read and analysed.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26290741","Text":"What behavior are you expecting? The type in the <code>Cast</code> value is existential, so you don&#39;t know anything about, e.g. how to show it. Your current GADT is essentially equivalent to something like <code>data Expr a = Value a | Cast (Expr a)</code>. You could add a <code>Show</code> constraint but I suspect that&#39;s a case of treating the symptom, and that what you should really do is take a step back and think about what you&#39;re trying to do in the first place.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26290704","Text":"It can&#39;t deduce that b is an instance of Show I guess, this compiles: <a href=\"http://ideone.com/BWtyIR\" rel=\"nofollow\">ideone.com/BWtyIR</a> and so does this <a href=\"http://ideone.com/6KiB3W\" rel=\"nofollow\">ideone.com/6KiB3W</a>","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26289957","Text":"Also: <code>Data.ByteString.Char8</code> is a bit of an &quot;experts-only&quot; module -- it&#39;s essentially broken for a lot of text in exchange for a bit of speed. Are you sure you shouldn&#39;t be using e.g. <code>Data.Text</code>?","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26289942","Text":"You should probably be using pattern-matching, or at the very least know how to use it -- it&#39;s much more fundamental than <code>fst</code>. And you&#39;re probably pattern-matching to handle the <code>Maybe</code> anyway -- I mean, you&#39;re surely not using <code>fromJust</code>, right? (<code>fromJust</code> is a partial function, which means it&#39;ll crash your program if it fails -- and with an unhelpful error message, too. You should pretty much never use it.)","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26289315","Text":"Cheers! fst just before worked like a charm!","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26289283","Text":"Use <code>fst</code> or pattern matching.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26289182","Text":"@Thomas Eding: someone just edited the name.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26281436","Text":"@Kochev In that case, you can disregard point #3 above. I was just offering it in case you had some other purpose in mind.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26281303","Text":"@shachaf: Thanks!\n@jozefg: <code>foo</code>&#39;s statefulness certainly isn&#39;t on par with the &quot;call up the pope to ask him which value his cat thinks we should return&quot; that the <code>IO</code> monad allows for. It&#39;s more like that of Control.Monad.State, except the state itself is opaque to Haskell.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26280807","Text":"I learn Haskell, because i want create library for myself.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26280687","Text":"So what&#39;s the advantage of doing this baton passing over just using IO? IO is actually like this under the covers","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26279058","Text":"There are some good slides on <a href=\"http://www.ugcs.caltech.edu/~keegan/talks/high-level-ffi/talk.pdf\" rel=\"nofollow\">High-Level FFI in Haskell</a> that go into doing this sort of thing.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26277051","Text":"Also <code>init &#91;foo&#93;</code> is <code>&#91;&#93;</code>, not an exception, so excluding one-element lists isn&#39;t even what a function named <code>safeInit</code> should be doing.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26276987","Text":"Note that using <code>length</code> like this is not idiomatic Haskell and also inefficient for large lists. Using pattern matching to exclude lists of length 1 would be the better solution.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26276804","Text":"<code>&#91;a&#93;</code> as a pattern-match would be the literal one-element-list. I think you might be meaning <code>xs</code> or <code>(x:xs)</code>. Try replacing <code>&#91;a&#93;</code> in your function definition (not the type) with <code>xs</code> or some other variable that starts with a lowercase.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26273393","Text":"+1 for Lambdabot","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26273296","Text":"@jozefg looks simple, just need yet another half an hour to let it into my mind :)","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26273143","Text":"@SergeyK. You say why in the next 2 sentences :)","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26273128","Text":"<code>f (g a b)</code> is exactly the same functionality, but <code>(.:)</code> keeps you in the compositional/plumbing/point-free state of mind. I usually use <code>f (g a b)</code> but occasionally <code>(.:)</code> is clearer.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272918","Text":"@Nathan Bouscal: interesting, why &quot;boobs&quot; are not popular among developers...","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272886","Text":"@tel: why not to use just <code>f (g a b)</code> as @jozefg shoed in his answer?","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272856","Text":"@SergeyK. From a quick grep, the <code>(.).(.)</code> operator (and its three-part and four-part analogues) are used in the GHC source in the MonadUtils package to define <code>liftIO2</code>, <code>liftIO3</code>, and <code>liftIO4</code>, but nowhere else in the whole source.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272838","Text":"@SergeyK. Any code that uses monads tends to favor names vs function composition since <code>do</code> notation is much much cleaner for monads","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272807","Text":"I cheated :) I&#39;ve already written out that whole reduction explanation before, so when @SergeyK said he wanted a non-functional answer I knew exactly the missing piece.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272754","Text":"@Nathan Bouscal: do you know any open-source Haskell project where this kind of thing can be found?","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272671","Text":"@SergeyK. In actual code you much more often see exactly what you&#39;re suggesting: a variable will be used and the functions will be composed regularly (with the <code>.</code> operator). Point-free style is nice, but readability comes first.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272653","Text":"@SergeyK. Take a look after my edits","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272384","Text":"@Jeff Burka: i&#39;ve got it. <code>Surprised owl</code> is, of course, romantic, but it is easier for me to imagine <code>boobs</code>.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272309","Text":"@SergeyK. because haskell functions are often written as pipes of many connected functions and it sucks to have to name each intermediate and often unimportant value. The <code>.</code> functions let&#39;s us connect together unary functions and the <code>(.).(.)</code> operator let&#39;s us connect in binary functions when we need them","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272271","Text":"@jozefg: cann&#39;t we just store the result of binary function somewhere and pass it to that unary function? Why it should bother about the arguments of the second function?","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272266","Text":":P You&#39;re one paragraph answer beats my full expansion/reduction of the functions involved, no fair","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272242","Text":"@SergeyK. Following from @jozefg, it provides a &quot;point-free&quot; way of doing this (mentioning no variables). Note that this isn&#39;t a special construct. It is derived from the more basic notion of function composition, written as a dot <code>.</code>.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272185","Text":"@SergeyK. if want to do it in such a way that you never mention the arguments you&#39;ll give to the binary function then yes you do need function to help","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272131","Text":"@dorchard: why do we need a special construct to just apply an unary function to the result of a binary functions? It is a trivial operation, isn&#39;t it?","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272032","Text":"The intuition part in my answer there is probably your best bet for a &quot;plain english&quot; explanation. I&#39;ll try again here, though.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26272030","Text":"@SergeyK. It just looks like that, it&#39;s really the <code>.</code> operator composed a few times. Some people call it the &quot;surprised owl&quot; operator.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26271995","Text":"@tel: that is pure functional thread, not a plain-English explanation.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26271989","Text":"@SergeyK. the name is not related to the meaning, just to the shape (although there&#39;s a nipple too many in the middle...).","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26271980","Text":"@SergeyK. Ok I&#39;ve commented a bit more","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26271976","Text":"@SergeyK. How about &quot;construct a function that applies a unary function to the result of a binary function&quot;?","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26271944","Text":"How &quot;boobs&quot; are related to the meaning of this operator? I don&#39;t get it.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26271883","Text":"@SergeyK.: is that a serious question? :)","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26271879","Text":"@larsmans: i don&#39;t know, i&#39;m a C++ developer and was just very curios.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26271828","Text":"@SergeyK.: how should one explain a higher-order function in a &quot;non-functional&quot; way?","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26271818","Text":"This isn&#39;t really functional. I&#39;m just expanding the function manually, take a second and read it through, This is really the same as in C++ with more concise syntax","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26271797","Text":"Can you explain it in a non-functional way?","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26271768","Text":"But why &quot;boobs&quot;?","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26271749","Text":"Looking at the type is instructive:\n\n    ((.) . (.)) :: (b -&gt; c) -&gt; (a -&gt; a1 -&gt; b) -&gt; a -&gt; a1 -&gt; c","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26271211","Text":"Thanks, works like a charm. :)","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26270475","Text":"You shouldn&#39;t use constraints on data types: <a href=\"http://stackoverflow.com/questions/12770278/typeclass-constraints-on-data-declarations\" title=\"typeclass constraints on data declarations\">stackoverflow.com/questions/12770278/&hellip;</a>","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26268980","Text":"That&#39;s quite alright, I learned something too :)","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26267594","Text":"Sorry, it appears I&#39;ve got to revise my last statement as Roman shows a nice solution to the problem.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26267525","Text":"Wow - this appears to be exactly what I needed. Also: nice to know that it&#39;s possible anyway :)","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26266762","Text":"Alright, I&#39;ve tried letting parsers return something like ParsecT s u m (State s u, a) and combine them the way I imagined when running runPT by injecting the state of one parser at the beginning of the next, but replacing the stateUser field. It turned out that this is too much a hell and your answer is pretty much what leads the way in this case. Thanks :)","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26266736","Text":"I&#39;m glad you found it helpful! Good luck!","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26265568","Text":"Thanks for the nice argumentation via the types of (&gt;&gt;=) and (&lt;*&gt;). I&#39;ll need a minute to test something, but you&#39;ve probably made me happy already.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26264449","Text":"type synonyms provide.... an exact synonym, so you can&#39;t extend an existing constructor thanks to them.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26264144","Text":"How about type synonyms? Can I use them?","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26263851","Text":"Yes, I was thinking, if the question is too open. However, in a way, this is related to an existing problem and I hope that this one could be answered, in an interesting way, so that the answer could benefit someone pondering with new package(s) now and in the future.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26263239","Text":"What&#39;s the question? This is not a place for suggesting improvements to Cabal or Hackage, or discussions about that. You should probably go to <a href=\"http://www.haskell.org/mailman/listinfo/cabal-devel\" rel=\"nofollow\">cabal-devel</a> mailing list for that stuff.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26263074","Text":"Thanks very much. It is exactly the case :)","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26262353","Text":"Thank you Fedor! :)","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26259238","Text":"Another way to look at it: using <code>zipWith id</code> means that each resulting element is computed by <code>id f v</code>, and <code>id f</code> equals <code>f</code> so <code>id f v</code> equals <code>f v</code>.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26256136","Text":"You should make person the last argument.  It seems better for partial application.  And you can rewrite using Kleisli composition, &lt;=&lt;.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26256002","Text":"@jk. I&#39;m glad you enjoyed it :)","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26255907","Text":"+1 for the blog post","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26253288","Text":"@JuanPablo Because <code>$</code> is really just <code>id</code>, specialised to only work on functions (and given a very low precedence and an infix notation). The type of <code>$</code>, given that it applies a function to an argument, has to be <code>(a -&gt; b) -&gt; a -&gt; b</code>. Remembering that all Haskell functions are &quot;really&quot; unary (or equivalently that <code>-&gt;</code> associates to the right), that the same type as <code>(a -&gt; b) -&gt; (a -&gt; b)</code>. Which means it takes a function of any type and gives you a function of the same type; just a special case of <code>id :: a -&gt; a</code> which takes a value of any type and gives you a value of the same type.","Language":"haskell"},{"DataSource":"stackoverflow.com","CommentId":"26252674","Text":"Any idea why that works?","Language":"haskell"}]